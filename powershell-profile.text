# oh-my-posh init pwsh --config "$env:POSH_THEMES_PATH\tokyo.omp.json" | Invoke-Expression
oh-my-posh init pwsh --config "$env:POSH_THEMES_PATH\zash.omp.json" | Invoke-Expression

$work= @{
    dir = 'C:\Users\iluha\work\zaelab'
    # temporary
    threekit = 'C:\Users\iluha\work\zaelab\composable'
    composable = 'C:\Users\iluha\work\zaelab\composable'
}

$pers = 'C:\Users\iluha\personal'


#Alias
Set-Alias vim nvim
Set-Alias ll ls
Set-Alias grep findstr
Set-Alias tig 'C:\Program Files\Git\usr\bin\tig.exe'
Set-Alias less 'C:\Program Files\Git\usr\bin\less.exe'
Set-Alias lg lazygit
Set-Alias gt git
Set-Alias -Name ccp -Value Copy-CurrentPath -Description "Alias for Copy-CurrentPath"

function work {
    Start-Process "$env:LOCALAPPDATA\slack\slack.exe"; cd $work.composable;  Start-Process "C:\Program Files\Highresolution Enterprises\X-Mouse Button Control\XMouseButtonControl.exe"; Start-Process "C:\Program Files\Google\Chrome\Application\chrome.exe"; Start-Process "C:\Program Files\OpenVPN\bin\openvpn-gui.exe"
}

function convert2gif {
    param (
        [string]$inputFileName,
        [Alias('c')]
        [switch]$copyToClipboard
    )

    # Check if the input file exists
    if (!(Test-Path $inputFileName)) {
        Write-Output "File $inputFileName not found."
        return
    }

    # Define the output GIF file name
    $outputFileName = [System.IO.Path]::ChangeExtension($inputFileName, "gif")

    # Run the FFmpeg command to convert the MP4 to GIF
    # Create gif directory if it doesn't exist
    if (!(Test-Path "./gif")) {
        New-Item -ItemType Directory -Path "./gif" -Force
    }
    ffmpeg -i $inputFileName -vf "fps=10,scale=1200:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" "./gif/$outputFileName"

    Write-Output "Conversion complete: $outputFileName"

    # Copy to clipboard if the flag is set
    if ($copyToClipboard) {
        Get-Item $outputFileName | Set-Clipboard
        Write-Output "GIF $outputFileName copied to clipboard"
    }
}

function convertWebp2png {
    param (
        [string]$inputFileName
    )

    # Check if the input file exists
    if (!(Test-Path $inputFileName)) {
        Write-Output "File $inputFileName not found."
        return
    }

    # Define the output GIF file name
    $outputFileName = [System.IO.Path]::ChangeExtension($inputFileName, "png")

    # Run FFmpeg command to convert the Webp to PNG

    ffmpeg -i $inputFileName $outputFileName

    Write-Output "Conversion complete: $outputFileName"
}

function phelp {
    Write-Host "Custom commands:"
    Write-Host "-----------------------------"
    Write-Host "convert2gif: accepts file name, or full path to the file and converts mp4 to gif"
    Write-Host "-----------------------------"
    Write-Host "convertWebp2png: accepts file name, or full path to the file and converts webp to png"
    Write-Host "-----------------------------"
    Write-Host "work: opens slack, 3kit directory, run x-mouse"
    Write-Host "-----------------------------"
    Write-Host "kill3000: kills process on port 3000"
    Write-Host "-----------------------------"
    Write-Host "GetBranchesDiff: receives two branch names ex: GetBranchesDiff main dev"
    Write-Host "-----------------------------"
    Write-Host "ccp: copies active path" 
}

function kill3000 {
    $processInfo = netstat -ano | findstr ":3000"
    if ($processInfo) {
        $pid = ($processInfo -split ' ')[-1]
        Write-Host "Killing process with PID: $pid"
        taskkill /PID $pid /F
    } else {
        Write-Host "No process found using port 3000"
    }
}

function GetBranchesDiff { 
    param(
        [string]$firstBranch,
        [string]$secondBranch
    )

    # Check if parameters were provided
    if ([string]::IsNullOrEmpty($firstBranch)) {
        Write-Output "First branch parameter is required."
        return
    }
    
    if ([string]::IsNullOrEmpty($secondBranch)) {
        Write-Output "Second branch parameter is required."
        return
    }

    # Check if branches exist in Git
    $firstBranchExists = git rev-parse --verify --quiet "origin/$firstBranch"
    if ($LASTEXITCODE -ne 0) {
        Write-Output "Branch '$firstBranch' not found in remote 'origin'."
        return
    }
    
    $secondBranchExists = git rev-parse --verify --quiet "origin/$secondBranch"
    if ($LASTEXITCODE -ne 0) {
        Write-Output "Branch '$secondBranch' not found in remote 'origin'."
        return
    }

    # Show diff between branches
    git diff --stat "origin/$firstBranch" "origin/$secondBranch"
}

function Find-LargestFiles {
    param (
        [Parameter(Mandatory=$false)]
        [string]$Path = ".",
        
        [Parameter(Mandatory=$false)]
        [string]$FilePattern = "*.tsx",
        
        [Parameter(Mandatory=$false)]
        [int]$Top = 10
    )

    Write-Host "Searching for $FilePattern files in $Path..." -ForegroundColor Cyan
    
    $files = Get-ChildItem -Path $Path -Recurse -File -Filter $FilePattern -ErrorAction SilentlyContinue
    
    if ($files.Count -eq 0) {
        Write-Host "No matching files found." -ForegroundColor Yellow
        return
    }
    
    Write-Host "Found $($files.Count) matching files. Counting lines..." -ForegroundColor Cyan
    
    $results = foreach ($file in $files) {
        try {
            $lineCount = (Get-Content $file.FullName -ErrorAction Stop | Measure-Object -Line).Lines
            [PSCustomObject]@{
                FileName = $file.FullName
                LineCount = $lineCount
            }
        }
        catch {
            Write-Host "Error processing $($file.FullName): $_" -ForegroundColor Red
        }
    }
    
    $sortedResults = $results | Sort-Object LineCount -Descending | Select-Object -First $Top
    
    Write-Host "Top $Top files by line count:" -ForegroundColor Green
    $sortedResults | Format-Table -AutoSize
}

function Copy-CurrentPath {
    <#
    .SYNOPSIS
        Copies the current working directory path to the Windows clipboard.
    .DESCRIPTION
        This function retrieves the full path of the current directory
        and sends it directly to the system clipboard using the 'clip' utility.
        This allows for quick pasting of the path into other applications.
    .EXAMPLE
        Copy-CurrentPath
        # Copies "C:\Users\YourUser\Documents" (or your current path) to clipboard.
    #>
    [CmdletBinding()]
    param()

    try {
        # Get the current location object and extract its Path property
        $currentPath = (Get-Location).Path

        # Pipe the path string to the 'clip' utility, which puts it on the clipboard
        $currentPath | clip

        Write-Host "Current path '$currentPath' copied to clipboard." -ForegroundColor Green
    }
    catch {
        Write-Error "Failed to copy path to clipboard: $($_.Exception.Message)"
    }
}
